<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Video Converter</title>
  <!-- Include ffmpeg.wasm from CDN -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 20px auto;
      padding: 20px;
      text-align: center;
    }
    h2 {
      color: #333;
    }
    select, input, button, a {
      margin: 10px;
      padding: 10px;
      font-size: 16px;
    }
    button {
      background-color: #4361ee;
      color: white;
      border: none;
      cursor: pointer;
      border-radius: 5px;
    }
    button:hover {
      background-color: #3a56d4;
    }
    a {
      display: none;
      background-color: #27ae60;
      color: white;
      text-decoration: none;
      border-radius: 5px;
      padding: 10px 20px;
    }
    a:hover {
      background-color: #219653;
    }
  </style>
</head>
<body>
  <h2>Simple Video Converter</h2>
  <input type="file" id="videoInput" accept="video/*">
  <div>
    <label for="outputFormat">Output Format:</label>
    <select id="outputFormat">
      <option value="mp4">MP4</option>
      <option value="webm">WEBM</option>
      <option value="gif">GIF</option>
    </select>
  </div>
  <div>
    <label for="quality">Quality:</label>
    <select id="quality">
      <option value="high">High</option>
      <option value="medium" selected>Medium</option>
      <option value="low">Low</option>
    </select>
  </div>
  <div>
    <label for="resolution">Resolution:</label>
    <select id="resolution">
      <option value="original">Original</option>
      <option value="1920x1080">1080p</option>
      <option value="1280x720">720p</option>
      <option value="854x480">480p</option>
    </select>
  </div>
  <button id="convertBtn">Convert Video</button>
  <a id="downloadLink">Download Converted Video</a>

  <script>
    // Function to convert a file to Uint8Array
    function fileToUint8Array(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(new Uint8Array(reader.result));
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    // Get DOM elements
    const videoInput = document.getElementById('videoInput');
    const convertBtn = document.getElementById('convertBtn');
    const downloadLink = document.getElementById('downloadLink');
    const outputFormat = document.getElementById('outputFormat');
    const quality = document.getElementById('quality');
    const resolution = document.getElementById('resolution');
    let uploadedFile;

    // Handle file upload
    videoInput.addEventListener('change', (e) => {
      uploadedFile = e.target.files[0];
      if (uploadedFile) {
        convertBtn.disabled = false;
      }
    });

    // Handle conversion
    convertBtn.addEventListener('click', async () => {
      if (!uploadedFile) {
        alert('Please select a video file first.');
        return;
      }

      try {
        // Load FFmpeg
        const { createFFmpeg } = FFmpeg;
        const ffmpeg = createFFmpeg({ log: true });
        await ffmpeg.load();

        // Write the input file to FFmpeg's file system
        const uint8Array = await fileToUint8Array(uploadedFile);
        ffmpeg.FS('writeFile', 'input', uint8Array);

        // Determine FFmpeg command based on user selections
        const format = outputFormat.value;
        let outputFile = `output.${format}`;
        let ffmpegArgs = ['-i', 'input'];

        // Map quality to CRF (Constant Rate Factor) for video quality
        const qualityMap = {
          high: '18',
          medium: '23',
          low: '28'
        };
        const crf = qualityMap[quality.value] || '23';

        // Map resolution to scale filter
        const resolutionMap = {
          '1920x1080': 'scale=1920:1080',
          '1280x720': 'scale=1280:720',
          '854x480': 'scale=854:480',
          original: null
        };
        const scaleFilter = resolutionMap[resolution.value];

        // Build FFmpeg command based on format
        if (format === 'mp4') {
          ffmpegArgs.push('-c:v', 'libx264', '-crf', crf, '-preset', 'fast', '-c:a', 'aac');
        } else if (format === 'webm') {
          ffmpegArgs.push('-c:v', 'libvpx-vp9', '-crf', crf, '-b:v', '0', '-c:a', 'libopus');
        } else if (format === 'gif') {
          ffmpegArgs.push('-vf', 'fps=10,scale=320:-1:flags=lanczos', '-loop', '0');
        }

        // Add resolution scaling if not original
        if (scaleFilter && format !== 'gif') {
          ffmpegArgs.push('-vf', scaleFilter);
        }

        // Add output file to arguments
        ffmpegArgs.push(outputFile);

        // Run FFmpeg command
        await ffmpeg.run(...ffmpegArgs);

        // Read the output file
        const data = ffmpeg.FS('readFile', outputFile);

        // Create a blob and download link
        const mimeType = format === 'gif' ? 'image/gif' : `video/${format}`;
        const blob = new Blob([data.buffer], { type: mimeType });
        const url = URL.createObjectURL(blob);
        downloadLink.href = url;
        downloadLink.download = outputFile;
        downloadLink.style.display = 'inline';
      } catch (error) {
        alert('Error during conversion: ' + error.message);
      }
    });
  </script>
</body>
</html>
